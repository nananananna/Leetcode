# 344.反转字符串
[题目链接： 344.反转字符串](https://leetcode.cn/problems/reverse-string/description/)  
[文章链接](https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html)  
[视频链接](https://www.bilibili.com/video/BV1fV4y17748/?spm_id_from=333.788&vd_source=bb16fbea368fef2149255510d2feefbe)  
状态：第一次自己a出来 😄

思路：双指针，left指向头，right指向尾，互换left和right的元素，直到left与right相遇

## 代码实现（Java）
```java
class Solution {
    public void reverseString(char[] s) {
        int left=0;
        int right=s.length-1;
        while(left<right){
            char temp = s[left];
            s[left]=s[right];
            s[right]=temp;
            left++;
            right--;
        }
    }
}
```
# 541.反转字符串II
[题目链接： 541.反转字符串II](https://leetcode.cn/problems/reverse-string-ii/description/)  
[文章链接](https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  
[视频链接](https://www.bilibili.com/video/BV1dT411j7NN/?spm_id_from=333.788&vd_source=bb16fbea368fef2149255510d2feefbe)  
状态：做不出来，卡在怎么对不同的剩余字符长度做处理上了

思路：对[344.反转字符串]()的延伸。我们可以按照2k的速度移动双指针`i`和`i+k-1`，每次判断`i+k-1<nums.length`。我们可以把 *344.反转字符串* 的代码封装到一个`函数reverse`中，当`i+k-1<nums.length`时，说明剩余字符大于等于k个小于2k个或大于2k个，`reverse(i,i+k-1)`。当`i+k-1>=nums.length`时，说明剩余字符小于k个，`reverse(i,nums.length-1)`。是否需要等号可以举例判断。
## 代码实现
```java
class Solution {
    public String reverseStr(String s, int k) {
        //String转char数组
        char[] nums = s.toCharArray();
        int length=nums.length;
        
        //每有2k个字符，反转前k个
        for(int i=0;i<length;i+=2*k){
            //剩余字符大于等于k个（k<=剩余字符<2k与剩余字符>2k都是反转前k个字符）
            if(i+k-1<length){
                reverse(nums,i,i+k-1);
            }
            else{
                //剩余字符小于k个，全部反转
                reverse(nums,i,length-1);
            }
        }
        //char数组转String
        return new String(nums);
    }

    //定义反转函数
    private void reverse(char[] nums,int left,int right){
        //344.反转链表的逻辑
        while(left<right){
            char temp=nums[left];
            nums[left]=nums[right];
            nums[right]=temp;

            left++;
            right--;
        }
    }
}
```

# 卡码网：54.替换数字 
[题目链接: 卡码网：54.替换数字](https://kamacoder.com/problempage.php?pid=1064)  
[文章链接](https://programmercarl.com/kamacoder/0054.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)    
状态：思路不对，没想到要先扩充字符串长度

思路：
1. Java不能直接修改`String`，所以先将其转为`char`型数组
2. 遍历`String`，记录有几个数字，新建扩充后的`char`数组
3. 双指针，一个指向原数组的末尾，另一个指向新数组的末尾，遇到非数字，从原数组复制；遇到数字，将对应的6位赋为'number'，一直移动双指针做赋值操作，直到指针为0。
4. 将新`char`数组转为`String` 
  
![](/images/8-1.png)
![](/images/8-2.png)

**⁺. ⊹˚₊ ₊·(੭  · ˕ · )੭🪄💫 注意**  
使用Java刷题的录友，一定要使用辅助空间，因为Java里的string不能修改。  <mark>其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后再从后向前进行操作。</mark>

## 代码实现
```java
import java.util.Scanner;

public class Main {
    
    public static String replaceNumber(String s) {
        int count = 0; // 统计数字的个数
        int sOldSize = s.length();
        for (int i = 0; i < s.length(); i++) {
            //判断s[i]是否为数字
            if(Character.isDigit(s.charAt(i))){
                count++;
            }
        }
        // 扩充字符串s的大小，也就是每个空格替换成"number"之后的大小
        char[] newS = new char[s.length() + count * 5];
        int sNewSize = newS.length;
        // 将旧字符串的内容填入新数组
        System.arraycopy(s.toCharArray(), 0, newS, 0, sOldSize);
        // 从后先前将空格替换为"number"
        for (int i = sNewSize - 1, j = sOldSize - 1; j < i; j--, i--) {
            if (!Character.isDigit(newS[j])) {
                newS[i] = newS[j];
            } else {
                newS[i] = 'r';
                newS[i - 1] = 'e';
                newS[i - 2] = 'b';
                newS[i - 3] = 'm';
                newS[i - 4] = 'u';
                newS[i - 5] = 'n';
                i -= 5;
            }
        }
        return new String(newS);
    };
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        System.out.println(replaceNumber(s));
        scanner.close();
    }
}
```

解释：`System.arraycopy` 是 Java 标准库中的一个方法，用于高效地复制数组的一部分内容到另一个数组中。它比手动循环复制更高效，因为它是一个本地方法，直接操作内存。下面是这行代码的详细解释：

```java
System.arraycopy(s.toCharArray(), 0, newS, 0, sOldSize);
```

### 解释各个参数

1. **`s.toCharArray()`**：
    - 这是一个将字符串 `s` 转换为 `char` 数组的方法。它返回一个字符数组，包含了字符串 `s` 中的所有字符。

2. **`0`（第一个 `0`）**：
    - 这是源数组（`s.toCharArray()`）中开始复制的起始位置索引。`0` 表示从源数组的第一个元素开始复制。

3. **`newS`**：
    - 这是目标数组，复制的内容将被放入这个数组中。在这个例子中，`newS` 是一个字符数组。

4. **`0`（第二个 `0`）**：
    - 这是目标数组（`newS`）中开始存放复制内容的起始位置索引。`0` 表示从目标数组的第一个元素开始放置复制的内容。

5. **`sOldSize`**：
    - 这是要复制的元素数量。`sOldSize` 表示从源数组复制多少个元素到目标数组。

### 代码示例

假设我们有以下变量和数组：

```java
String s = "Hello, World!";
char[] newS = new char[20]; // 目标数组，大小为20
int sOldSize = s.length(); // sOldSize 为字符串 s 的长度，即13
```

然后，我们执行 `System.arraycopy`：

```java
System.arraycopy(s.toCharArray(), 0, newS, 0, sOldSize);
```

执行上述代码后，`newS` 数组的前 `13` 个元素将包含字符串 `s` 中的字符，而其余元素将保持为默认值 `'\u0000'`（空字符）。

### 整体作用

`System.arraycopy(s.toCharArray(), 0, newS, 0, sOldSize);` 的作用是：

1. 将字符串 `s` 转换为字符数组。
2. 从字符数组的第一个元素开始，复制 `sOldSize` 个元素到目标数组 `newS` 的起始位置。

### 示例代码

下面是一个完整的示例，展示如何使用 `System.arraycopy`：

```java
public class ArrayCopyExample {
    public static void main(String[] args) {
        String s = "Hello, World!";
        char[] newS = new char[20]; // 目标数组，大小为20
        int sOldSize = s.length(); // sOldSize 为字符串 s 的长度，即13

        // 执行数组复制
        System.arraycopy(s.toCharArray(), 0, newS, 0, sOldSize);

        // 输出结果
        System.out.println(new String(newS)); // 输出: Hello, World!
    }
}
```

### 解释

1. **字符串转换为字符数组**：
    ```java
    s.toCharArray() // 将字符串 s 转换为字符数组
    ```

2. **数组复制**：
    ```java
    System.arraycopy(s.toCharArray(), 0, newS, 0, sOldSize);
    ```
    - 将 `s` 转换为的字符数组从索引 `0` 开始，复制 `sOldSize` 个元素到 `newS` 数组的起始位置。

3. **输出结果**：
    ```java
    System.out.println(new String(newS)); // 输出: Hello, World!
    ```
    - 将 `newS` 数组转换为字符串并输出。因为 `newS` 数组有 20 个元素，其中前 13 个元素为 `s` 的字符，剩下的元素为默认值 `'\u0000'`（空字符），但这些空字符在字符串输出中不会显示。

通过使用 `System.arraycopy`，可以高效地复制数组内容，避免手动循环操作，简化代码，提高性能。