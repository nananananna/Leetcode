# 344.反转字符串
[题目链接： 344.反转字符串](https://leetcode.cn/problems/reverse-string/description/)  
[文章链接](https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html)  
[视频链接](https://www.bilibili.com/video/BV1fV4y17748/?spm_id_from=333.788&vd_source=bb16fbea368fef2149255510d2feefbe)  
状态：第一次自己a出来 😄

思路：双指针，left指向头，right指向尾，互换left和right的元素，直到left与right相遇

## 代码实现（Java）
```java
class Solution {
    public void reverseString(char[] s) {
        int left=0;
        int right=s.length-1;
        while(left<right){
            char temp = s[left];
            s[left]=s[right];
            s[right]=temp;
            left++;
            right--;
        }
    }
}
```
# 541.反转字符串II
[题目链接： 541.反转字符串II](https://leetcode.cn/problems/reverse-string-ii/description/)  
[文章链接](https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  
[视频链接](https://www.bilibili.com/video/BV1dT411j7NN/?spm_id_from=333.788&vd_source=bb16fbea368fef2149255510d2feefbe)  
状态：做不出来，卡在怎么对不同的剩余字符长度做处理上了

思路：对[344.反转字符串]()的延伸。我们可以按照2k的速度移动双指针`i`和`i+k-1`，每次判断`i+k-1<nums.length`。我们可以把 *344.反转字符串* 的代码封装到一个`函数reverse`中，当`i+k-1<nums.length`时，说明剩余字符大于等于k个小于2k个或大于2k个，`reverse(i,i+k-1)`。当`i+k-1>=nums.length`时，说明剩余字符小于k个，`reverse(i,nums.length-1)`。是否需要等号可以举例判断。
## 代码实现
```java
class Solution {
    public String reverseStr(String s, int k) {
        //String转char数组
        char[] nums = s.toCharArray();
        int length=nums.length;
        
        //每有2k个字符，反转前k个
        for(int i=0;i<length;i+=2*k){
            //剩余字符大于等于k个（k<=剩余字符<2k与剩余字符>2k都是反转前k个字符）
            if(i+k-1<length){
                reverse(nums,i,i+k-1);
            }
            else{
                //剩余字符小于k个，全部反转
                reverse(nums,i,length-1);
            }
        }
        //char数组转String
        return new String(nums);
    }

    //定义反转函数
    private void reverse(char[] nums,int left,int right){
        //344.反转链表的逻辑
        while(left<right){
            char temp=nums[left];
            nums[left]=nums[right];
            nums[right]=temp;

            left++;
            right--;
        }
    }
}
```

# 卡码网：54.替换数字 
[题目链接: 卡码网：54.替换数字](https://kamacoder.com/problempage.php?pid=1064)  
[文章链接](https://programmercarl.com/kamacoder/0054.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)    
状态：思路不对，没想到要先扩充字符串长度

思路：
1. Java不能直接修改`String`，所以先将其转为`char`型数组
2. 遍历`String`，记录有几个数字，新建扩充后的`char`数组
3. 双指针，一个指向原数组的末尾，另一个指向新数组的末尾，遇到非数字，从原数组复制；遇到数字，将对应的6位赋为'number'，一直移动双指针做赋值操作，直到指针为0。
4. 将新`char`数组转为`String`

**⁺. ⊹˚₊ ₊·(੭  · ˕ · )੭🪄💫 注意**  
使用Java刷题的录友，一定要使用辅助空间，因为Java里的string不能修改。  <mark>其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后再从后向前进行操作。</mark>

## 代码实现
```java
import java.util.Scanner;

public class Main {
    
    public static String replaceNumber(String s) {
        int count = 0; // 统计数字的个数
        int sOldSize = s.length();
        for (int i = 0; i < s.length(); i++) {
            //判断s[i]是否为数字
            if(Character.isDigit(s.charAt(i))){
                count++;
            }
        }
        // 扩充字符串s的大小，也就是每个空格替换成"number"之后的大小
        char[] newS = new char[s.length() + count * 5];
        int sNewSize = newS.length;
        // 将旧字符串的内容填入新数组
        System.arraycopy(s.toCharArray(), 0, newS, 0, sOldSize);
        // 从后先前将空格替换为"number"
        for (int i = sNewSize - 1, j = sOldSize - 1; j < i; j--, i--) {
            if (!Character.isDigit(newS[j])) {
                newS[i] = newS[j];
            } else {
                newS[i] = 'r';
                newS[i - 1] = 'e';
                newS[i - 2] = 'b';
                newS[i - 3] = 'm';
                newS[i - 4] = 'u';
                newS[i - 5] = 'n';
                i -= 5;
            }
        }
        return new String(newS);
    };
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        System.out.println(replaceNumber(s));
        scanner.close();
    }
}
```